#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <syscall.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <errno.h>
 
int main(void)
{
long long counter = 0;  /*  machine instruction counter */14.
int wait_val;           /*  child's return value        */
int pid;                /*  child's process id          */
 
puts("Please wait");
switch (pid = fork()) {

case -1:
perror("fork");
break;
case 0: /*  child process starts        */
ptrace(PTRACE_TRACEME, 0, 0, 0);
/*
*  must be called in order to allow the
*  control over the child process
*/
execl("./hello", "hello", NULL);
/*
*  executes the program and causes
*  the child to stop and send a signal
*  to the parent, the parent can now
*  switch to PTRACE_SINGLESTEP  
*/
break;
/*  child process ends  */
default:/*  parent process starts       */
wait(&wait_val);
/*  
*   parent waits for child to stop at next
*   instruction (execl())
43.
*/
while (wait_val == 1407 ) {
counter++;
if (ptrace(PTRACE_SINGLESTEP, pid, 0, 0) != 0)
perror("ptrace");
/*
*   switch to singlestep tracing and
*   release child
*   if unable call error.
*/
wait(&wait_val);
/*   wait for next instruction to complete  */
}

/*
* continue to stop, wait and release until
* the child is finished; wait_val != 1407
* Low=0177L and High=05 (SIGTRAP)
*/
}
printf("Number of machine instructions : %lld\n", counter);
return 0;
}

? switch(pid = fork())
??? {
??? case -1:
??????? return -1;
??? case 0: //子进程
??????? ptrace(PTRACE_TRACEME,0,NULL,NULL);
??????? execl("./hello", "hello", NULL);
??? default: //父进程
??????? wait(&val); //等待并记录execve
??????? if(WIFEXITED(val))
??????????? return 0;
??????? syscallID=ptrace(PTRACE_PEEKUSER, pid, ORIG_EAX*4, NULL);
??????? printf("Process executed system call ID = %ld/n",syscallID);
??????? ptrace(PTRACE_SYSCALL,pid,NULL,NULL);
??????? while(1)
??????? {
??????????? wait(&val); //等待信号
??????????? if(WIFEXITED(val)) //判断子进程是否退出
??????????????? return 0;
??????????? if(flag==0) //第一次(进入系统调用)，获取系统调用的参数
??????????? {
??????????????? syscallID=ptrace(PTRACE_PEEKUSER, pid, ORIG_EAX*4, NULL);
??????????????? printf("Process executed system call ID = %ld ",syscallID);
??????????????? flag=1;
??????????? }
??????????? else //第二次(退出系统调用)，获取系统调用的返回值
??????????? {
??????????????? returnValue=ptrace(PTRACE_PEEKUSER, pid, EAX*4, NULL);
??????????????? printf("with return value= %ld/n", returnValue);
??????????????? flag=0;
??????????? }
??????????? ptrace(PTRACE_SYSCALL,pid,NULL,NULL);
??????? }
??? }
